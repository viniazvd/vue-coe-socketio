'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var logUpdate = _interopDefault(require('log-update'));
var chalk = _interopDefault(require('chalk'));
var stringifyAuthor = _interopDefault(require('stringify-author'));
var firstCommitDate = _interopDefault(require('first-commit-date'));
var UseConfig = _interopDefault(require('use-config'));
var findBabelConfig = _interopDefault(require('find-babel-config'));
var util = _interopDefault(require('util'));
var EventEmitter = _interopDefault(require('events'));
var globby = _interopDefault(require('globby'));
var fs = _interopDefault(require('fs-extra'));
var rollup = require('rollup');
var camelcase = _interopDefault(require('camelcase'));
var bytes = _interopDefault(require('bytes'));
var gzipSize = _interopDefault(require('gzip-size'));
var stringWidth = _interopDefault(require('string-width'));
var boxen = _interopDefault(require('boxen'));
var nodeResolvePlugin = _interopDefault(require('rollup-plugin-node-resolve'));
var commonjsPlugin = _interopDefault(require('rollup-plugin-commonjs'));
var jsonPlugin = _interopDefault(require('rollup-plugin-json'));
var uglifyPlugin = _interopDefault(require('rollup-plugin-uglify'));
var aliasPlugin = _interopDefault(require('rollup-plugin-alias'));
var replacePlugin = _interopDefault(require('rollup-plugin-replace'));
var hashbangPlugin = _interopDefault(require('rollup-plugin-hashbang'));
var isBuiltinModule = _interopDefault(require('is-builtin-module'));
var textTable = _interopDefault(require('text-table'));
var resolveFrom = _interopDefault(require('resolve-from'));
var isCI = _interopDefault(require('is-ci'));

const PREFIX = `\0virtual:`;
function virtual(modules, cwd) {
  const resolvedIds = new Map();

  if (modules) {
    Object.keys(modules).forEach(id => {
      resolvedIds.set(path.resolve(cwd, id), modules[id]);
    });
  }

  return {
    name: 'virtual',

    resolveId(id, importer) {
      if (!modules) return;

      if (importer) {
        if (importer.startsWith(PREFIX)) {
          importer = importer.slice(PREFIX.length);
        }

        const resolved = path.resolve(path.dirname(importer), id);
        if (resolvedIds.has(resolved)) return PREFIX + resolved;
      } else {
        // Entry files
        const resolved = path.resolve(id);
        if (resolvedIds.has(resolved)) return PREFIX + resolved;
      }
    },

    load(id) {
      if (id.startsWith(PREFIX)) {
        id = id.slice(PREFIX.length);
        return resolvedIds.get(id);
      }
    }

  };
}

const supportsEmoji = process.platform !== 'win32' || process.env.TERM === 'xterm-256color'; // Fallback symbols for Windows from https://en.wikipedia.org/wiki/Code_page_437

var emoji = {
  progress: supportsEmoji ? '⏳' : '∞',
  success: supportsEmoji ? '✨' : '√',
  error: supportsEmoji ? '🚨' : '×',
  warning: supportsEmoji ? '⚠️' : '‼'
};

const relativePath = p => path.relative(process.cwd(), path.resolve(p));

const prettyPluginName = name => {
  return name === 'rpt2' ? 'typescript2' : name;
};

const prettyPluginError = err => {
  if (err.plugin === 'rpt2') {
    return err.message.replace(/\.ts\((\d+),(\d+)\):\s*/, '.ts:$1:$2\n');
  }

  return err.message;
};

const prettyError = err => {
  if (err.name === 'BiliError') {
    return {
      message: err.message
    };
  }

  let message;
  const frames = [];

  if (err.plugin) {
    message = `(${prettyPluginName(err.plugin)}) ${prettyPluginError(err)}`;
    frames.push(err.codeFrame || err.snippet);
  } else {
    message = err.message;

    if (err.loc) {
      message += ` at ${relativePath(err.loc.file || err.id)}:${err.loc.line}:${err.loc.column}`;
    }

    if (err.url) {
      frames.push(err.url);
    }

    frames.push(chalk.red(err.frame || err.stack));
  }

  return {
    message,
    frames: frames.join('\n')
  };
};

class Logger {
  constructor(options) {
    this.setOptions(options);
  }

  setOptions(options = {}) {
    this.logLevel = typeof options.logLevel === 'number' ? options.logLevel : 3;
    this.useLogUpdate = typeof options.logUpdate === 'boolean' ? options.logUpdate : true;
  }

  clear() {
    if (this.useLogUpdate) {
      logUpdate.clear();
    }
  }

  write(message, persistent = false) {
    if (persistent) {
      this.clear();
      console.log(message);
      return;
    }

    if (this.useLogUpdate) {
      logUpdate(message);
    } else {
      console.log(message);
    }
  } // Debug message
  // Always persisted


  debug(message) {
    if (this.logLevel < 4) {
      return;
    }

    this.write(message, true);
  } // Normal log
  // Persist by default


  log(message, update) {
    if (this.logLevel < 3) {
      return;
    }

    this.write(message, !update);
  } // Warn status


  warn(message) {
    if (this.logLevel < 2) {
      return;
    }

    this.status(emoji.warning, message);
  } // Error status


  error(err) {
    if (this.logLevel < 1) {
      return;
    }

    if (typeof err === 'string') {
      return this.status(emoji.error, err);
    }

    let _prettyError = prettyError(err),
        message = _prettyError.message,
        frames = _prettyError.frames;

    this.status(emoji.error, message);

    if (frames) {
      console.error(frames);
    }
  } // Status message should be persisted
  // Unless `update` is set
  // Mainly used in `progress-plugin.js`


  status(emoji$$1, message, update) {
    if (this.logLevel < 3) {
      return;
    }

    if (update && this.useLogUpdate) {
      return logUpdate(`${emoji$$1}  ${message}`);
    }

    this.clear();
    console.log(`${emoji$$1}  ${message}`);
  }

}

var logger = new Logger();

var progressPlugin = (() => {
  let bundling = 0;
  return {
    name: 'bili-progress',

    transform(code, id) {
      logger.status(emoji.progress, `Bundling ${chalk.cyan(++bundling)} file${bundling > 1 ? 's' : ''}: ${chalk.green(path.relative(process.cwd(), id))}`, true);
    },

    ongenerate() {
      bundling = 0;
    }

  };
});

var template = ((tpl, data) => {
  if (typeof tpl !== 'string') {
    throw new TypeError(`Expected a string in the first argument, got ${typeof tpl}`);
  }

  if (typeof data !== 'object') {
    throw new TypeError(`Expected an Object/Array in the second argument, got ${typeof data}`);
  }

  const re = /\[(.*?)\]/g;
  return tpl.replace(re, (_, key) => {
    let ret = data;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = key.split('.')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const prop = _step.value;
        ret = ret ? ret[prop] : '';
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return ret || '';
  });
});

var getBanner = ((banner, pkg) => {
  if (!banner || typeof banner === 'string') {
    return banner;
  }

  pkg = typeof banner === 'object' ? Object.assign({}, pkg, banner) : pkg;
  const name = pkg.name;

  if (typeof name !== 'string') {
    throw new TypeError(`Expect "name" in package.json to be a string but got ${typeof name}.`);
  }

  const version = pkg.version ? `v${pkg.version}` : '';
  let year = pkg.year;

  if (!year) {
    try {
      const date = firstCommitDate.sync();
      year = new Date(date).getFullYear();
    } catch (e) {
      year = new Date().getFullYear();
    }
  }

  let author = typeof pkg.author === 'string' ? pkg.author : typeof pkg.author === 'object' ? stringifyAuthor(pkg.author) : '';
  author = author ? author : '';
  const license = pkg.license || '';
  banner = '/*!\n' + ` * ${name} ${version}\n` + ` * (c) ${year}-present ${author}\n` + (license && ` * Released under the ${license} License.\n`) + ' */';
  return banner;
});

class BiliError extends Error {
  constructor(message) {
    super(message);
    this.name = 'BiliError';
  }

}

function getBabelConfig(cwd, disableBabelRc, babelOptions) {
  // Only find babelrc one level deep
  const _findBabelConfig$sync = findBabelConfig.sync(cwd, 1),
        file = _findBabelConfig$sync.file;

  const babelConfig = {
    babelrc: false,
    runtimeHelpers: true
  };

  if (file && !disableBabelRc) {
    logger.debug(`${chalk.bold('Babel config')}:\n${file}`);
    babelConfig.extends = file;
  }

  if (!babelConfig.extends) {
    // Use our default preset when no babelrc was found
    babelConfig.presets = [[require.resolve('./babel'), babelOptions]];
  }

  return babelConfig;
}
function getBiliConfig(_config) {
  const useConfig = new UseConfig({
    name: 'bili',
    files: _config ? [_config] : ['package.json', '{name}.config.js', '.{name}rc']
  });

  const _useConfig$loadSync = useConfig.loadSync(),
        configPath = _useConfig$loadSync.path,
        config = _useConfig$loadSync.config;

  if (configPath) {
    logger.debug(chalk.bold(`Bili config file: ${path.relative(process.cwd(), configPath)}`));
  } else if (_config) {
    throw new BiliError(`Cannot find Bili config file at ${_config}`);
  }

  return config;
}

function handleError(err) {
  process.exitCode = process.exitCode || 1;

  if (err.message.includes('You must supply options.name for UMD bundles')) {
    return logger.error(`You must supply ${chalk.green('options.moduleName')} for UMD bundles, the easiest way is to use ${chalk.green('--moduleName')} flag.\n${getDocRef('api', 'modulename')}`);
  }

  logger.error(err);
}
function getDocRef(page, id) {
  return chalk.dim(`📖  https://egoist.moe/bili/#/${page}${id ? `?id=${id}` : ''}`);
}

const FORMATS = ['cjs'];

const prettyBytes = v => bytes.format(v, {
  unitSeparator: ' '
});

class Bili extends EventEmitter {
  static generate(options) {
    try {
      return new Bili(options).bundle({
        write: false
      });
    } catch (err) {
      handleError(err);
    }
  }

  static write(options) {
    return new Promise(function ($return, $error) {
      var bundler, startTime, buildTime, time;

      var $Try_2_Post = function () {
        try {
          return $return();
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this);

      var $Try_2_Catch = function (err) {
        try {
          handleError(err);
          return $Try_2_Post();
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this);

      try {
        bundler = new Bili(options);
        startTime = Date.now();
        return Promise.resolve(bundler.bundle()).then(function ($await_9) {
          try {
            buildTime = Date.now() - startTime;
            time = buildTime < 1000 ? `${buildTime}ms` : `${(buildTime / 1000).toFixed(2)}s`;

            if (!options.watch) {
              logger.status(emoji.success, chalk.green(`Built in ${time}.`));
              return Promise.resolve(bundler.stats()).then(function ($await_10) {
                try {
                  logger.log($await_10);
                  return $If_7.call(this);
                } catch ($boundEx) {
                  return $Try_2_Catch($boundEx);
                }
              }.bind(this), $Try_2_Catch);
            }

            function $If_7() {
              return $return(bundler);
            }

            return $If_7.call(this);
          } catch ($boundEx) {
            return $Try_2_Catch($boundEx);
          }
        }.bind(this), $Try_2_Catch);
      } catch (err) {
        $Try_2_Catch(err);
      }
    }.bind(this));
  }

  constructor(options = {}) {
    super();
    logger.setOptions(options);
    this.options = Object.assign({
      outDir: 'dist',
      filename: '[name][suffix].js',
      cwd: process.cwd(),
      target: 'browser',
      js: null,
      babel: {}
    }, options.config !== false && getBiliConfig(options.config), options);
    this.babelPresetOptions = {
      objectAssign: this.options.objectAssign,
      jsx: this.options.jsx,
      target: this.options.target,
      buble: false
    };
    this.options.babel = Object.assign({}, getBabelConfig(this.options.cwd, this.options.babel.babelrc === false, this.babelPresetOptions), this.options.babel);
    this.pkg = readPkg(this.options.cwd);
    this.pkgName = this.pkg.name && this.pkg.name.replace(/^@.+\//, '');
    this.bundles = {};
    this.cssBundles = new Map();

    this.handleError = err => handleError(err);
  }

  stats() {
    return new Promise(function ($return, $error) {
      var bundles, sizeLimit, sizes;
      let leading, sizeExceeded;
      bundles = this.bundles;
      sizeLimit = this.options.sizeLimit;
      leading = '';
      sizeExceeded = false;
      return Promise.resolve(Promise.all(Object.keys(bundles).sort().map(filepath => new Promise(function ($return, $error) {
        var _bundles$filepath, code, relative, formatFull, gzipSizeNumber, expectedSize;

        let sizeInfo;
        _bundles$filepath = bundles[filepath], code = _bundles$filepath.code, relative = _bundles$filepath.relative, formatFull = _bundles$filepath.formatFull;
        return Promise.resolve(gzipSize(code)).then(function ($await_11) {
          try {
            gzipSizeNumber = $await_11;
            expectedSize = sizeLimit && sizeLimit[formatFull] && bytes.parse(sizeLimit[formatFull]);

            if (expectedSize && gzipSizeNumber > expectedSize) {
              process.exitCode = 1;
              sizeExceeded = true;
              sizeInfo = chalk.red(` threshold: ${prettyBytes(expectedSize)}`);
            } else {
              sizeInfo = '';
            }

            return $return([relative, prettyBytes(code.length), chalk.green(prettyBytes(gzipSizeNumber)) + sizeInfo]);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this))))).then(function ($await_12) {
        try {
          sizes = $await_12;

          if (sizeExceeded) {
            leading = chalk.red(`${emoji.error}  Bundle size exceeded the limit, check below for details.\n`);
          }

          return Promise.resolve(Promise.all(Array.from(this.cssBundles.keys()).sort().map(id => new Promise(function ($return, $error) {
            var bundle;
            bundle = this.cssBundles.get(id);
            return Promise.resolve(gzipSize(bundle.code)).then(function ($await_13) {
              try {
                sizes.push([path.relative(process.cwd(), bundle.filepath), prettyBytes(bundle.code.length), chalk.green(prettyBytes($await_13))]);
                return $return();
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }.bind(this), $error);
          }.bind(this))))).then(function ($await_14) {
            try {
              return $return(leading + boxen(textTable([['file', 'size', 'gzip size'].map(v => chalk.bold(v)), ...sizes], {
                stringLength: stringWidth
              })));
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }.bind(this), $error);
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    }.bind(this));
  }

  resolveCwd(...args) {
    return path.resolve(this.options.cwd, ...args);
  }

  loadUserPlugins({
    plugins,
    filename
  }) {
    // eslint-disable-next-line array-callback-return
    return plugins.map(pluginName => {
      // In bili.config.js or you're using the API
      // You can require rollup plugin directly
      if (typeof pluginName === 'object') {
        return pluginName;
      }

      let pluginOptions = this.options[pluginName];

      if (pluginName === 'vue') {
        pluginOptions = Object.assign({
          include: ['**/*.vue'],
          // Let rollup-plugin-postcss handle external CSS dependencies
          autoStyles: false,
          styleToImports: true,
          css: path.resolve(this.options.outDir, filename.replace(/\.[^.]+$/, '.css'))
        }, pluginOptions);
      }

      const moduleName = isPath(pluginName) ? path.resolve(pluginName) : `rollup-plugin-${pluginName}`;

      try {
        // TODO:
        // Local require is always relative to `process.cwd()`
        // Instead of `this.options.cwd`
        // We need to ensure that which is actually better
        const p = localRequire(moduleName);
        return p.default ? p.default(pluginOptions) : p(pluginOptions);
      } catch (err) {
        handleLoadPluginError(moduleName, err);
      }
    });
  }

  writeCSS() {
    return new Promise(function ($return, $error) {
      return Promise.resolve(Promise.all(Array.from(this.cssBundles.keys()).map(id => {
        const _cssBundles$get = this.cssBundles.get(id),
              code = _cssBundles$get.code,
              map = _cssBundles$get.map,
              filepath = _cssBundles$get.filepath;

        return Promise.all([fs.writeFile(filepath, code, 'utf8'), map && fs.writeFile(`${filepath}.map`, map, 'utf8')]);
      }))).then(function ($await_15) {
        try {
          return $return();
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    }.bind(this));
  }

  getJsOptions(name, pluginOptions) {
    if (name === 'babel') {
      return this.options.babel;
    }

    if (name === 'typescript' || name === 'typescript2') {
      let typescript;

      try {
        typescript = localRequire('typescript');
      } catch (err) {}

      return Object.assign({
        typescript
      }, pluginOptions);
    }

    if (name === 'buble') {
      return Object.assign({}, pluginOptions, {
        transforms: Object.assign({
          // Skip transforming for..of
          forOf: false
        }, pluginOptions && pluginOptions.transforms)
      });
    }

    return pluginOptions;
  } // eslint-disable-next-line complexity


  createConfig({
    input,
    format,
    formatFull,
    compress
  }, {
    multipleEntries
  }) {
    return new Promise(function ($return, $error) {
      const options = this.options.extendOptions ? this.options.extendOptions(this.options, {
        input,
        format,
        compress
      }) : this.options;
      logger.debug(chalk.bold(`Bili options for ${input} in ${formatFull}:\n`) + util.inspect(options, {
        colors: true
      }));

      if (typeof options !== 'object') {
        return $error(new BiliError('You must return the options in `extendOptions` method!'));
      }

      const outDir = options.outDir,
            filename = options.filename;
      let inline = options.inline || format === 'umd' || format === 'iife';

      if (typeof inline === 'string') {
        inline = [inline];
      }

      const sourceMap = typeof options.map === 'boolean' ? options.map : compress;
      const outFilename = getFilename({
        input,
        format,
        filename,
        compress,
        // If it's not bundling multi-entry
        // The name can fallback to pkg name
        name: options.name || !multipleEntries && this.pkgName
      }); // The path to output file
      // Relative to `this.options.cwd`

      const file = this.resolveCwd(outDir, outFilename);
      const transformJS = options.js !== false;
      const jsPluginName = transformJS && getJsPluginName(options.js, input);
      const jsPlugin = transformJS && getJsPlugin(jsPluginName);
      const jsOptions = transformJS && this.getJsOptions(jsPluginName, options[jsPluginName]);
      const banner = getBanner(options.banner, this.pkg);
      let external = getArrayOption(options, 'external') || [];
      external = external.map(e => e.startsWith('./') ? path.resolve(options.cwd, e) : e);
      let globals = options.globals || options.global;

      if (typeof globals === 'object') {
        external = [...new Set(external.concat(Object.keys(globals)))];
      }

      let env = options.env;

      if (format === 'umd' || format === 'iife') {
        env = Object.assign({
          NODE_ENV: compress ? 'production' : 'development'
        }, env);
      }

      const inputOptions = {
        input,
        external,
        onwarn: err => {
          if (options.quiet) return;

          if (typeof err === 'string') {
            return logger.warn(err);
          }

          const loc = err.loc,
                frame = err.frame,
                message = err.message,
                code = err.code,
                source = err.source;

          if (options.quiet || code === 'THIS_IS_UNDEFINED') {
            return;
          } // Unresolved modules
          // If `inline` is not trusty there will always be this warning
          // But we only need this when the module is not installed
          // i.e. does not exist on disk


          if (code === 'UNRESOLVED_IMPORT' && source) {
            if ( // Skip sub path for now
            source.indexOf('/') === -1 && // Skip built-in modules
            !isBuiltinModule(source) && // Check if the module exists
            resolveFrom.silent(process.cwd(), source) === null) {
              logger.warn(`Module "${source}" was not installed, you may run "${chalk.cyan(`${getPackageManager()} add ${source}`)}" to install it!`);
            }

            return;
          } // print location if applicable


          if (loc) {
            logger.warn(`${loc.file} (${loc.line}:${loc.column}) ${message}`);
            if (frame) logger.warn(chalk.dim(frame));
          } else {
            logger.warn(message);
          }
        },
        plugins: [!isCI && process.stderr.isTTY && process.env.NODE_ENV !== 'test' && options.progress !== false && progressPlugin(), hashbangPlugin(), options.virtualModules && virtual(options.virtualModules, this.options.cwd), ...this.loadUserPlugins({
          filename: outFilename,
          plugins: getArrayOption(options, 'plugin') || []
        }), jsonPlugin(), require('rollup-plugin-postcss')(Object.assign({
          extract: true,
          minimize: compress,
          sourceMap
        }, options.postcss, {
          onExtract: getExtracted => {
            // Use `z` `a` to ensure the order when we log the stats
            const id = `${input}::${compress ? 'z-compressed' : 'a-normal'}`;

            if (!this.cssBundles.has(id)) {
              // Don't really need suffix for format
              const filepath = this.resolveCwd(outDir, outFilename.replace(/(\.(iife|cjs|es))?(\.min)?\.js$/, compress ? '.min.css' : '.css'));
              const bundle = getExtracted(filepath);
              this.cssBundles.set(id, Object.assign({}, bundle, {
                filepath
              }));
            } // We extract CSS but never atually let `rollup-plugin-postcss` write to disk
            // To prevent from duplicated css files


            return false;
          }
        })), transformJS && jsPluginName === 'buble' && require('rollup-plugin-babel')({
          include: '**/*.js',
          exclude: 'node_modules/**',
          babelrc: false,
          presets: [[require.resolve('./babel'), Object.assign({}, this.babelPresetOptions, {
            buble: true
          })]]
        }), transformJS && jsPlugin(Object.assign({
          exclude: 'node_modules/**'
        }, jsOptions)), inline && nodeResolvePlugin(Object.assign({
          module: true,
          extensions: ['.js', '.json'],
          preferBuiltIns: true,
          browser: !options.target.startsWith('node'),
          only: Array.isArray(inline) ? inline : null
        }, options.nodeResolve)), commonjsPlugin(options.commonjs), compress && uglifyPlugin(Object.assign({}, options.uglify, {
          output: Object.assign({}, options.uglify && options.uglify.output, {
            // Add banner (if there is)
            preamble: banner
          })
        })), options.alias && aliasPlugin(options.alias), options.replace && replacePlugin(options.replace), {
          name: 'bili',
          ongenerate: (_, {
            code
          }) => {
            this.bundles[file] = {
              relative: path.relative(process.cwd(), file),
              input,
              format,
              formatFull,
              compress,
              code
            };
          }
        }, env && Object.keys(env).length > 0 && replacePlugin({
          values: Object.keys(env).reduce((res, key) => {
            res[`process.env.${key}`] = JSON.stringify(env[key]);
            return res;
          }, {})
        })].filter(v => Boolean(v))
      };
      const outputOptions = {
        format,
        globals,
        name: this.getModuleName(format),
        file,
        banner,
        exports: options.exports,
        sourcemap: sourceMap
      };
      return $return({
        inputOptions,
        outputOptions
      });
    }.bind(this));
  }

  bundle({
    write = true
  } = {}) {
    return new Promise(function ($return, $error) {
      var magicPatterns, formats, options, multipleEntries, actions, bundleCount, hasName, hasSuffix, msg;
      let inputFiles;
      inputFiles = this.options.input;

      if (!inputFiles || inputFiles.length === 0) {
        inputFiles = ['src/index.js'];
      }

      if (!Array.isArray(inputFiles)) {
        inputFiles = [inputFiles];
      }

      magicPatterns = [];
      inputFiles = inputFiles.filter(v => {
        if (globby.hasMagic(v)) {
          magicPatterns.push(v);
          return false;
        }

        return true;
      });
      return Promise.resolve(globby(magicPatterns, {
        cwd: this.options.cwd
      }).then(files => {
        inputFiles = inputFiles.concat(files).map(v => relativePath(this.resolveCwd(v)));
      })).then(function ($await_16) {
        try {
          if (inputFiles.length === 0) {
            return $error(new BiliError('No matched files to bundle.'));
          }

          formats = getArrayOption(this.options, 'format') || FORMATS;
          options = inputFiles.reduce((res, input) => [...res, ...formats.map(format => {
            const compress = format.endsWith('-min');
            return {
              input,
              format: format.replace(/-min$/, ''),
              formatFull: format,
              compress
            };
          })], []);
          multipleEntries = inputFiles.length > 1;
          actions = options.map(option => new Promise(function ($return, $error) {
            var _ref, inputOptions, outputOptions, watcher, bundle;

            return Promise.resolve(this.createConfig(option, {
              multipleEntries
            })).then(function ($await_17) {
              try {
                _ref = $await_17, inputOptions = _ref.inputOptions, outputOptions = _ref.outputOptions;
                logger.debug(chalk.bold(`Rollup input options for bundling ${option.input} in ${option.formatFull}:\n`) + util.inspect(inputOptions, {
                  colors: true
                }));
                logger.debug(chalk.bold(`Rollup output options for bundling ${option.input} in ${option.formatFull}:\n`) + util.inspect(outputOptions, {
                  colors: true
                }));

                if (this.options.watch) {
                  watcher = rollup.watch(Object.assign({}, inputOptions, {
                    output: outputOptions,
                    watch: {
                      clearScreen: true
                    }
                  }));
                  watcher.on('event', e => new Promise(function ($return, $error) {
                    if (e.code === 'ERROR' || e.code === 'FATAL') {
                      handleError(e.error);
                    }

                    if (e.code === 'BUNDLE_END') {
                      process.exitCode = 0;
                      return Promise.resolve(this.stats()).then(function ($await_18) {
                        try {
                          logger.write($await_18);
                          return $If_8.call(this);
                        } catch ($boundEx) {
                          return $error($boundEx);
                        }
                      }.bind(this), $error);
                    }

                    function $If_8() {
                      return $return();
                    }

                    return $If_8.call(this);
                  }.bind(this)));
                  return $return();
                }

                return Promise.resolve(rollup.rollup(inputOptions)).then(function ($await_19) {
                  try {
                    bundle = $await_19;
                    if (write) return $return(bundle.write(outputOptions));
                    return $return(bundle.generate(outputOptions));
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }.bind(this), $error);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }.bind(this), $error);
          }.bind(this)));
          return Promise.resolve(Promise.all(actions)).then(function ($await_20) {
            try {
              return Promise.resolve(nextTick()).then(function ($await_21) {
                try {
                  bundleCount = Object.keys(this.bundles).length;

                  if (bundleCount < formats.length * inputFiles.length) {
                    hasName = this.options.filename.includes('[name]');
                    hasSuffix = this.options.filename.includes('[suffix]');
                    msg = `Multiple files are emitting to the same path.\nPlease check if ${hasName || inputFiles.length === 1 ? '' : `${chalk.green('[name]')}${hasSuffix ? '' : ' or '}`}${hasSuffix ? '' : chalk.green('[suffix]')} is missing in ${chalk.green('filename')} option.\n${getDocRef('api', 'filename')}`;
                    return $error(new BiliError(msg));
                  } // Write potential CSS files


                  return Promise.resolve(this.writeCSS()).then(function ($await_22) {
                    try {
                      return $return(this);
                    } catch ($boundEx) {
                      return $error($boundEx);
                    }
                  }.bind(this), $error);
                } catch ($boundEx) {
                  return $error($boundEx);
                }
              }.bind(this), $error);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }.bind(this), $error);
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this), $error);
    }.bind(this));
  }

  getModuleName(format) {
    if (format !== 'umd' && format !== 'iife') return undefined;
    return this.options.moduleName || this.pkg.moduleName || (this.pkgName ? camelcase(this.pkgName) : undefined);
  }

}

function getSuffix(format) {
  let suffix = '';

  switch (format) {
    case 'cjs':
      suffix += '.cjs';
      break;

    case 'umd':
      break;

    case 'es':
      suffix += '.es';
      break;

    case 'iife':
      suffix += '.iife';
      break;

    default:
      throw new Error('unsupported format');
  }

  return suffix;
}

function getNameFromInput(input) {
  return path.basename(input, path.extname(input));
}

function getFilename({
  input,
  format,
  filename,
  compress,
  name
}) {
  name = name || getNameFromInput(input);
  const suffix = getSuffix(format);
  const res = template(filename, {
    name,
    suffix
  });
  return compress ? path.basename(res, path.extname(res)) + '.min' + path.extname(res) : res;
}

function getJsPlugin(name) {
  let req;

  if (isPath(name)) {
    req = require;
    name = path.resolve(name);
  } else {
    req = name === 'babel' || name === 'buble' ? require : localRequire;
    name = `rollup-plugin-${name}`;
  }

  try {
    return req(name);
  } catch (err) {
    handleLoadPluginError(name, err);
  }
}

function localRequire(name) {
  return require(path.resolve('node_modules', name));
}

function isPath(v) {
  return /^[./]|(^[a-zA-Z]:)/.test(v);
}

function handleLoadPluginError(moduleName, err) {
  if (err.code === 'MODULE_NOT_FOUND' && err.message.includes(moduleName)) {
    let msg = `Cannot find plugin "${chalk.cyan(moduleName)}" in current directory!`;
    const pm = getPackageManager();
    const command = pm === 'yarn' ? `yarn add ${moduleName} --dev` : `npm install -D ${moduleName}`;

    if (!isPath(moduleName)) {
      msg += `\n${chalk.dim(`You may run "${command}" to install it.`)}`;
    }

    throw new BiliError(msg);
  } else {
    throw err;
  }
}

function nextTick() {
  return new Promise(resolve => {
    process.nextTick(() => {
      resolve();
    });
  });
}

function getArrayOption(options, name) {
  const option = options[name] || options[`${name}s`];
  if (typeof option === 'string') return option.split(',');
  return option;
}

let packageManager;

function getPackageManager() {
  if (packageManager) return packageManager;
  packageManager = fs.existsSync('yarn.lock') ? 'yarn' : 'npm';
  return packageManager;
}

function readPkg(cwd = process.cwd()) {
  try {
    return require(path.resolve(cwd, 'package.json'));
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      return {};
    }

    throw err;
  }
}

function getJsPluginName(name, input) {
  if (name) {
    return name;
  }

  if (input.endsWith('.ts')) {
    return 'typescript2';
  }

  return 'babel';
}

module.exports = Bili;
